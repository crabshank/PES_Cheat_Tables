<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="42">
  <CheatEntries>
    <CheatEntry>
      <ID>77</ID>
      <Description>"BATCH ENABLE"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$lua}

local al=getAddressList()
local scrpts={}
local first=false
for i=0, al.Count-1 do --skip ENABLE
    local ai=al[i]
    if ai.type==11 then
       if first==false then
          first=true
       else
           table.insert(scrpts,ai)
       end
    end
end

[ENABLE]
-- COMMENT OUT ANY UNWANTED SCRIPTS
scrpts[1].Active=true -- Left arm
scrpts[2].Active=true -- Twist
scrpts[3].Active=true -- Legs dist
scrpts[4].Active=true -- Animation change
scrpts[5].Active=true -- Animation speed
scrpts[6].Active=true -- Pre-kick rush
scrpts[7].Active=true -- Brodacst focus
scrpts[8].Active=true -- Angle hijack (stadium)
scrpts[9].Active=true -- Cutscenes heights
scrpts[10].Active=true -- Smoother anim
scrpts[11].Active=true -- Game speed

[DISABLE]
scrpts[1].Active=false -- Left arm
scrpts[2].Active=false -- Twist
scrpts[3].Active=false -- Legs dist
scrpts[4].Active=false -- Animation change
scrpts[5].Active=false -- Animation speed
scrpts[6].Active=false -- Pre-kick rush
scrpts[7].Active=false -- Brodacst focus
scrpts[8].Active=false -- Angle hijack (stadium)
scrpts[9].Active=false -- Cutscenes heights
scrpts[10].Active=false -- Smoother anim
scrpts[11].Active=true -- Game speed
</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>57</ID>
          <Description>"Left arm"</Description>
          <Options moHideChildren="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
local vars={}
--OPTIONAL (Add as named element of 'vars' table to use in '$%s{...}' notation)
local suffix='_la'
vars.varis_1_n='mult'..suffix

local m1=1 -- mean
local r1=0 -- range

vars.varis_1_d='dd (float)'..m1..'\ndd (float)'..r1
vars.varis_1_size=8
local parts={{'[^%]]+',1,'localAddress'},{'%d+',1,'xreg_n'},{'xmm%d+',1,'x_reg'},{'mov.+',1,'mov_op'}}
local module_names='PES2021.exe'

vars.post={}

vars.post[1]=function() --gives names "xmm~1" to "xmm~15" to all registers that are not 'x_reg'
 local xn=tonumber(vars.xreg_n)
 local c=1
 for i=0,15 do
  if xn~=i then
   vars['xmm~'..c]='xmm'..i
   c=c+1
  end
 end
 return vars --IMPORTANT!
end

-- token functions (below) run after ['post'] functions
vars['push_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s='sub rsp,10\nmovdqu [rsp], '
    if n=='0' then
		return s .. vars['x_reg']
	else
		return s .. vars['xmm~'..n]
	end
end

vars['pop_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s=',[rsp]\nadd rsp,10'
    if n=='0' then
		return 'movdqu '..vars['x_reg'] .. s
	else
		return 'movdqu '..vars['xmm~'..n] .. s
	end
end

vars['stack_push']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'sub rsp, ' .. n
end

vars['stack_pop']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'add rsp, ' .. n
end

--COMPULSORY
local newmem_name='newmem'..suffix
local newmem_size='$1000'
local script_ref='Left_arm' --  opcode_inj[vars.script_ref] stores vars
local inj_name='INJECT'..suffix
local pattern='^%s*mov.+%s*xmm%d+,%s*%[[^%]]+%]'
local aobs={'48 89 44 24 20 C7 44 24 28 FF FF FF FF 89 44 24 2C',-24,0}
local lookahead_n=32

local inj_script=[[
define(${inj_name},${address_string})
  registersymbol(${inj_name})
  alloc(${newmem_name}, ${newmem_size}, ${inj_name})

  alloc(${varis_1_n}, $%d{varis_1_size}, ${inj_name})
  registersymbol(${varis_1_n})
  ${varis_1_n}:
  ${varis_1_d}

  label(code)
  label(return)

  ${newmem_name}:
  code:
    push rcx
    push rbx
    push rax

    mov rax,[7FFE0014] //Windows internal clock
    mov rbx,rax
    shl rbx,6
    mov rcx,rax
    shl rcx,18
    imul rcx,rbx
    imul rcx,rax
    shr rcx,20 //ecx has the number
 ${push_xmm}(1)
    ${push_xmm}(2)
    ${push_xmm}(3)
    ${push_xmm}(4)
    ${push_xmm}(5)
    ${push_xmm}(0)

    cvtsi2ss ${x_reg}, rcx
    cvtss2sd ${x_reg}, ${x_reg}

    ${stack_push}(8)
        mov [rsp],FFE00000
        mov [rsp+4],41EFFFFF //move max_float into stack
        divsd ${x_reg}, [rsp] //div by max float (in double precision)
    ${stack_pop}(8)

    cvtsd2ss ${x_reg}, ${x_reg} //random float in ${x_reg}

    cvtss2si ecx, ${x_reg}  //b as int
    cvtsi2ss  ${xmm~5}, ecx // b

    ${stack_push}(20)
        mov [rsp], C0000000 //-2
        mov [rsp+4], 3F800000 //1
        mov [rsp+8], 40000000 //2
        mov [rsp+C], 3F3504F3 //sqHalf

        movss ${xmm~1},  [rsp+C] //sqHalf
        movss ${xmm~2}, [rsp] //-2
        movss ${xmm~3}, [rsp+4] //1
        movss ${xmm~4}, [rsp+8] //2

        mulss ${xmm~4}, ${xmm~5} //x~4=b*2
        subss ${xmm~3}, ${xmm~4} // x~3=1-b*2
        mulss ${xmm~1}, ${xmm~3} // x~1 = ( sqHalf* (1-b*2) )
        mulss ${xmm~2}, ${xmm~5} //x~2 = -2*b
        mulss ${xmm~2}, ${x_reg} // x~2=(-2*b)*x
        addss ${xmm~2}, ${xmm~5}//x~2=(-2*b*x)+b
        addss ${xmm~2}, ${x_reg} // x~2=(-2*b*x)+b+x
        sqrtss ${xmm~2}, ${xmm~2} // // x~2=sqrt(-2*b*x+b+x)
        mulss  ${xmm~1},${xmm~2} // x~1 = ( sqHalf* (1-b*2) )*sqrt(-2*b*x+b+x)
        addss ${xmm~1}, ${xmm~5} //  x~1 = b+ ( sqHalf* (1-b*2) )*sqrt(-2*b*x+b+x) || FINAL!

        mov [rsp+10], 3F800000 //1
        mov [rsp+14], 3F800000 //1
        mov [rsp+18], 3F800000 //1
        mov [rsp+1C], 3F800000 //1

        movups ${xmm~4}, [rsp+10] //x~4={1,1,1,1}
    ${stack_pop}(20)

    mulss  ${xmm~4},  [${varis_1_n}+4] //{r,1,1,1}
    movss  ${xmm~3},  [${varis_1_n}] //u
    subss  ${xmm~3},  ${xmm~4}
    mulss  ${xmm~4},  ${xmm~1} //mul by adj_x
    addss  ${xmm~4},  ${xmm~4}
    addss  ${xmm~4},  ${xmm~3} //FINAL MULT in x~4 !
    pslldq ${xmm~4},8 //(?,r,~,~)
    ${stack_push}(20)
        movdqu [rsp], ${xmm~4}
        mov [rsp], 3F800000 //1
        mov [rsp+4], 3F800000 //1
        mov [rsp+C], 3F800000 //1
        movups ${xmm~4}, [rsp] ////(1,r,r,1)
    ${stack_pop}(20)

    ${pop_xmm}(0)
	$%s{opcode}  //loads 4 x floats into $%s{x_reg}
	mulps ${x_reg},${xmm~4}

    ${pop_xmm}(5)
    ${pop_xmm}(4)
    ${pop_xmm}(3)
    ${pop_xmm}(2)
    ${pop_xmm}(1)
    pop rax
    pop rbx
    pop rcx
      $%s{overwritten}
	  jmp return

	$%s{inj_name}:
	  jmp $%s{newmem_name}
	  $%s{post_jmp}
      return:
]]

[ENABLE]
opcode_inj.inject(script_ref,inj_name,newmem_name,newmem_size,vars,inj_script,pattern,aobs,lookahead_n,parts,module_names)

[DISABLE]
opcode_inj.disable(script_ref)
opcode_inj[script_ref]=nil
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>60</ID>
              <Description>"Left arm mean"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_la</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>68</ID>
              <Description>"Left arm range"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_la+4</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>39</ID>
          <Description>"Twist (left) + Right arm"</Description>
          <Options moHideChildren="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
local vars={}
--OPTIONAL (Add as named element of 'vars' table to use in '$%s{...}' notation)
local suffix='_ra'
vars.varis_1_n='mult'..suffix

local m1=1 -- Right arm mean
local r1=0 -- Right arm range
local m2=1 -- Twist (left) mean
local r2=0 -- Twist (left) range

vars.varis_1_d='dd (float)'..m1..'\ndd (float)'..r1..'\ndd (float)'..m2..'\ndd (float)'..r2
vars.varis_1_size=16
local parts={{'[^%]]+',1,'localAddress'},{'%d+',1,'xreg_n'},{'xmm%d+',1,'x_reg'},{'mov.+',1,'mov_op'}}
local module_names='PES2021.exe'
vars.post={}

vars.post[1]=function() --gives names "xmm~1" to "xmm~15" to all registers that are not 'x_reg'
 local xn=tonumber(vars.xreg_n)
 local c=1
 for i=0,15 do
  if xn~=i then
   vars['xmm~'..c]='xmm'..i
   c=c+1
  end
 end
 return vars --IMPORTANT!
end

-- token functions (below) run after ['post'] functions
vars['push_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s='sub rsp,10\nmovdqu [rsp], '
    if n=='0' then
		return s .. vars['x_reg']
	else
		return s .. vars['xmm~'..n]
	end
end

vars['pop_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s=',[rsp]\nadd rsp,10'
    if n=='0' then
		return 'movdqu '..vars['x_reg'] .. s
	else
		return 'movdqu '..vars['xmm~'..n] .. s
	end
end

vars['stack_push']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'sub rsp, ' .. n
end

vars['stack_pop']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'add rsp, ' .. n
end

--COMPULSORY
local newmem_name='newmem'..suffix
local newmem_size='$1000'
local script_ref='Twist_left_right_arm' --  opcode_inj[vars.script_ref] stores vars
local inj_name='INJECT'..suffix
local pattern='^%s*mov.+%s*xmm%d+,%s*%[[^%]]+%]'
local aobs={'41 0F 28 C0 48 8B BC 24 88 00 00 00 41 8B CB',-32,0}
local lookahead_n=32

local inj_script=[[
	define(${inj_name},${address_string})
    registersymbol(${inj_name})
    alloc(${newmem_name}, ${newmem_size}, ${inj_name})
	alloc(${varis_1_n}, $%d{varis_1_size}, ${inj_name})
    registersymbol(${varis_1_n})
	${varis_1_n}:
	${varis_1_d}

	label(code)
	label(return)

	${newmem_name}:
	code:
    ${push_xmm}(6)
    push rcx
    push rbx
    push rax
    ${push_xmm}(8)
    ${push_xmm}(7)
    ${push_xmm}(4)
    ${push_xmm}(1)
    ${push_xmm}(2)
    ${push_xmm}(3)
    ${push_xmm}(5)
    ${push_xmm}(0)

${stack_push}(18)
    mov rax,[7FFE0014] //Windows internal clock
    mov rbx,rax
    shl rbx,6
    mov rcx,rax
    shl rcx,18
    imul rcx,rbx
    imul rcx,rax
    shr rcx,20 //ecx has the number

    cvtsi2ss ${xmm~7}, rcx
    cvtss2sd ${xmm~7}, ${xmm~7}

        mov [rsp],FFE00000
        mov [rsp+4],41EFFFFF //move max_float into stack
        divsd ${xmm~7}, [rsp] //div by max float (in double precision)


    cvtsd2ss ${xmm~7}, ${xmm~7} //random float in ${xmm~7}

    cvtss2si ecx, ${xmm~7}  //b as int
    cvtsi2ss  ${xmm~8}, ecx // b

    movss ${x_reg},${xmm~7}
    movss ${xmm~5},${xmm~8}

    //ROUND 2

    mov rbx,[7FFE0014] //Windows internal clock
    mov rbx,rax
    shl rbx,6
    mov rcx,rax
    shl rcx,18
    imul rcx,rbx
    imul rcx,rax
    shr rcx,20 //ecx has the number

    cvtsi2ss ${xmm~7}, rcx
    cvtss2sd ${xmm~7}, ${xmm~7}

        divsd ${xmm~7}, [rsp] //div by max float (in double precision)

    cvtsd2ss ${xmm~7}, ${xmm~7} //random float in ${xmm~7}

    cvtss2si ecx, ${xmm~7}  //b as int
    cvtsi2ss  ${xmm~8}, ecx // b

    pslldq ${x_reg},4
    movss ${x_reg},${xmm~7}
     pslldq ${xmm~5},4
    movss ${xmm~5},${xmm~8}

        mov [rsp+8], C0000000 //-2
        mov [rsp+C], 3F800000 //1
        mov [rsp+10], 40000000 //2
        mov [rsp+14], 3F3504F3 //sqHalf

        movss ${xmm~1},  [rsp+14] //sqHalf
        shufps ${xmm~1},${xmm~1},0 // every element := [0]
        movss ${xmm~2}, [rsp+8] //-2
        shufps ${xmm~2},${xmm~2},0 // every element := [0]
        movss ${xmm~3}, [rsp+C] //1
        shufps ${xmm~3},${xmm~3},0 // every element := [0]
        movss ${xmm~4}, [rsp+10] //2
        shufps ${xmm~4},${xmm~4},0 // every element := [0]

        mulps ${xmm~4}, ${xmm~5} //x~4=b*2
        subps ${xmm~3}, ${xmm~4} // x~3=1-b*2
        mulps ${xmm~1}, ${xmm~3} // x~1 = ( sqHalf* (1-b*2) )
        mulps ${xmm~2}, ${xmm~5} //x~2 = -2*b
        mulps ${xmm~2}, ${x_reg} // x~2=(-2*b)*x
        addps ${xmm~2}, ${xmm~5}//x~2=(-2*b*x)+b
        addps ${xmm~2}, ${x_reg} // x~2=(-2*b*x)+b+x
        sqrtps ${xmm~2}, ${xmm~2} // // x~2=sqrt(-2*b*x+b+x)
        mulps  ${xmm~1},${xmm~2} // x~1 = ( sqHalf* (1-b*2) )*sqrt(-2*b*x+b+x)
        addps ${xmm~1}, ${xmm~5} //  x~1 = b+ ( sqHalf* (1-b*2) )*sqrt(-2*b*x+b+x) || FINAL!


	movss ${xmm~5}, [${varis_1_n}+C]
    movss ${xmm~4}, ${xmm~5}
	pslldq ${xmm~4},4
	movss ${xmm~5}, [${varis_1_n}+4]
    movss ${xmm~4}, ${xmm~5}


    movss ${xmm~5}, [${varis_1_n}+8]
    movss ${xmm~3}, ${xmm~5}
	pslldq ${xmm~3},4
	movss ${xmm~5}, [${varis_1_n}]
    movss ${xmm~3}, ${xmm~5}

    subps  ${xmm~3},  ${xmm~4}
    mulps  ${xmm~4},  ${xmm~1} //mul by adj_x
    addps  ${xmm~4},  ${xmm~4}
    addps  ${xmm~4},  ${xmm~3} //FINAL MULTS in x~4 !

    movups ${xmm~6}, ${xmm~4} // (~,~,r,r)
    pslldq ${xmm~6},4 //(~,r,r,~)

        movdqu [rsp], ${xmm~6}
        mov [rsp], 3F800000 //1
        mov [rsp+C], 3F800000 //1
        movups ${xmm~6}, [rsp] ////(1,r,r,1)
    ${stack_pop}(18)

    ${pop_xmm}(0)
    ${pop_xmm}(5)
    ${pop_xmm}(3)
    ${pop_xmm}(2)
    ${pop_xmm}(1)
    ${pop_xmm}(4)
    ${pop_xmm}(7)
    ${pop_xmm}(8)
    pop rax
    pop rbx
    pop rcx
      ${opcode}
      mulps ${x_reg},${xmm~6}
      ${pop_xmm}(6)
      ${overwritten}
	  jmp return

	${inj_name}:
	  jmp ${newmem_name}
	  ${post_jmp}
	return:
]]

[ENABLE]
opcode_inj.inject(script_ref,inj_name,newmem_name,newmem_size,vars,inj_script,pattern,aobs,lookahead_n,parts,module_names)

[DISABLE]
opcode_inj.disable(script_ref)
opcode_inj[script_ref]=nil
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>44</ID>
              <Description>"Right arm mean"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_ra</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>67</ID>
              <Description>"Right arm"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_ra+4</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>66</ID>
              <Description>"Twist (left) mean"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_ra+8</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>45</ID>
              <Description>"Twist (left) range"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_ra+C</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>47</ID>
          <Description>"Legs dist from body"</Description>
          <Options moHideChildren="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
local vars={}
--OPTIONAL (Add as named element of 'vars' table to use in '$%s{...}' notation)
local suffix='_d'

vars.varis_1_n='mult'..suffix

local m1=1 -- mean
local r1=0 -- range

vars.varis_1_d='dd (float)'..m1..'\ndd (float)'..r1
vars.varis_1_size=8   --(u +0, r +4)

vars.push_xmm='sub rsp,10\nmovdqu [rsp],'
vars.pop_xmm=',[rsp]\nadd rsp,10'

local parts={{'[^%]]+',1,'localAddress'},{'%d+',1,'xreg_n'},{'xmm%d+',1,'x_reg'},{'mov.+',1,'mov_op'}}
local module_names='PES2021.exe'
vars.post={}

vars.post[1]=function() --gives names "xmm~1" to "xmm~15" to all registers that are not 'x_reg'
 local xn=tonumber(vars.xreg_n)
 local c=1
 for i=0,15 do
  if xn~=i then
   vars['xmm~'..c]='xmm'..i
   c=c+1
  end
 end
 return vars --IMPORTANT!
end

-- token functions (below) run after ['post'] functions
vars['push_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s='sub rsp,10\nmovdqu [rsp], '
    if n=='0' then
		return s .. vars['x_reg']
	else
		return s .. vars['xmm~'..n]
	end
end

vars['pop_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s=',[rsp]\nadd rsp,10'
    if n=='0' then
		return 'movdqu '..vars['x_reg'] .. s
	else
		return 'movdqu '..vars['xmm~'..n] .. s
	end
end

vars['stack_push']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'sub rsp, ' .. n
end

vars['stack_pop']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'add rsp, ' .. n
end

--COMPULSORY
local newmem_name='newmem'..suffix
local newmem_size='$1000'
local script_ref='Legs_dist_body' --  opcode_inj[vars.script_ref] stores vars
local inj_name='INJECT'..suffix
local pattern='^%s*mov.+%s*xmm%d+,%s*%[[^%]]+%]'
local aobs={'FF FF FF FF 48 89 44 24 24 89 44 24 2C 0F 28 4C 24 20 0F 54 C1',-32,0}
local lookahead_n=32

local inj_script=[[
	  define(${inj_name},${address_string})
  registersymbol(${inj_name})
  alloc(${newmem_name}, ${newmem_size}, ${inj_name})

  alloc(${varis_1_n}, $%d{varis_1_size}, ${inj_name})
  registersymbol(${varis_1_n})
  ${varis_1_n}:
  ${varis_1_d}

  label(code)
  label(return)

  ${newmem_name}:
  code:
    push rcx
    push rbx
    push rax

    mov rax,[7FFE0014] //Windows internal clock
    mov rbx,rax
    shl rbx,6
    mov rcx,rax
    shl rcx,18
    imul rcx,rbx
    imul rcx,rax
    shr rcx,20 //ecx has the number
 ${push_xmm}(1)
    ${push_xmm}(2)
    ${push_xmm}(3)
    ${push_xmm}(4)
    ${push_xmm}(5)
    ${push_xmm}(0)

    cvtsi2ss ${x_reg}, rcx
    cvtss2sd ${x_reg}, ${x_reg}

    ${stack_push}(8)
        mov [rsp],FFE00000
        mov [rsp+4],41EFFFFF //move max_float into stack
        divsd ${x_reg}, [rsp] //div by max float (in double precision)
    ${stack_pop}(8)

    cvtsd2ss ${x_reg}, ${x_reg} //random float in ${x_reg}

    cvtss2si ecx, ${x_reg}  //b as int
    cvtsi2ss  ${xmm~5}, ecx // b

    ${stack_push}(20)
        mov [rsp], C0000000 //-2
        mov [rsp+4], 3F800000 //1
        mov [rsp+8], 40000000 //2
        mov [rsp+C], 3F3504F3 //sqHalf

        movss ${xmm~1},  [rsp+C] //sqHalf
        movss ${xmm~2}, [rsp] //-2
        movss ${xmm~3}, [rsp+4] //1
        movss ${xmm~4}, [rsp+8] //2

        mulss ${xmm~4}, ${xmm~5} //x~4=b*2
        subss ${xmm~3}, ${xmm~4} // x~3=1-b*2
        mulss ${xmm~1}, ${xmm~3} // x~1 = ( sqHalf* (1-b*2) )
        mulss ${xmm~2}, ${xmm~5} //x~2 = -2*b
        mulss ${xmm~2}, ${x_reg} // x~2=(-2*b)*x
        addss ${xmm~2}, ${xmm~5}//x~2=(-2*b*x)+b
        addss ${xmm~2}, ${x_reg} // x~2=(-2*b*x)+b+x
        sqrtss ${xmm~2}, ${xmm~2} // // x~2=sqrt(-2*b*x+b+x)
        mulss  ${xmm~1},${xmm~2} // x~1 = ( sqHalf* (1-b*2) )*sqrt(-2*b*x+b+x)
        addss ${xmm~1}, ${xmm~5} //  x~1 = b+ ( sqHalf* (1-b*2) )*sqrt(-2*b*x+b+x) || FINAL!

        mov [rsp+10], 3F800000 //1
        mov [rsp+14], 3F800000 //1
        mov [rsp+18], 3F800000 //1
        mov [rsp+1C], 3F800000 //1

        movups ${xmm~4}, [rsp+10] //x~4={1,1,1,1}
    ${stack_pop}(20)

    mulss  ${xmm~4},  [${varis_1_n}+4] //{r,1,1,1}
    movss  ${xmm~3},  [${varis_1_n}] //u
    subss  ${xmm~3},  ${xmm~4}
    mulss  ${xmm~4},  ${xmm~1} //mul by adj_x
    addss  ${xmm~4},  ${xmm~4}
    addss  ${xmm~4},  ${xmm~3} //FINAL MULT in x~4 !

    ${pop_xmm}(0)
	$%s{opcode}  //loads 4 x floats into $%s{x_reg}
	mulps ${x_reg},${xmm~4}

    ${pop_xmm}(5)
    ${pop_xmm}(4)
    ${pop_xmm}(3)
    ${pop_xmm}(2)
    ${pop_xmm}(1)
    pop rax
    pop rbx
    pop rcx
      $%s{overwritten}
	  jmp return

	$%s{inj_name}:
	  jmp $%s{newmem_name}
	  $%s{post_jmp}
	return:
]]

[ENABLE]
opcode_inj.inject(script_ref,inj_name,newmem_name,newmem_size,vars,inj_script,pattern,aobs,lookahead_n,parts,module_names)

[DISABLE]
opcode_inj.disable(script_ref)
opcode_inj[script_ref]=nil
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>48</ID>
              <Description>"Distance mean"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_d</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>62</ID>
              <Description>"Distance range"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_d+4</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>0</ID>
          <Description>"Animation change"</Description>
          <Options moHideChildren="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
local vars={}
--OPTIONAL (Add as named element of 'vars' table to use in '$%s{...}' notation)
local suffix='_anim'
vars.varis_1_n='mult_1'

local m1=1 -- Arms in/out mean
local r1=0 -- Arms in/out range
local m2=1 -- Arms dist mean
local r2=0 -- Arms dist range
local m3=1 -- Lean avg
local r3=0 -- Lean range

vars.varis_1_d='dd (float)'..m1..'\ndd (float)'..r1..'\ndd (float)'..m2..'\ndd (float)'..r2..'\ndd (float)'..m3..'\ndd (float)'..r3
vars.varis_1_size=24
local parts={{'[^%]]+',1,'localAddress'},{'%d+',1,'xreg_n'},{'xmm%d+',1,'x_reg'},{'mov.+',1,'mov_op'}}
local module_names='PES2021.exe'
vars.post={}

vars.post[1]=function() --gives names "xmm~1" to "xmm~15" to all registers that are not 'x_reg'
 local xn=tonumber(vars.xreg_n)
 local c=1
 for i=0,15 do
  if xn~=i then
   vars['xmm~'..c]='xmm'..i
   c=c+1
  end
 end
 return vars --IMPORTANT!
end

-- token functions (below) run after ['post'] functions
vars['push_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s='sub rsp,10\nmovdqu [rsp], '
    if n=='0' then
		return s .. vars['x_reg']
	else
		return s .. vars['xmm~'..n]
	end
end

vars['pop_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s=',[rsp]\nadd rsp,10'
    if n=='0' then
		return 'movdqu '..vars['x_reg'] .. s
	else
		return 'movdqu '..vars['xmm~'..n] .. s
	end
end

vars['stack_push']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'sub rsp, ' .. n
end

vars['stack_pop']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'add rsp, ' .. n
end

--COMPULSORY
local newmem_name='newmem'..suffix
local newmem_size='$2000'
local script_ref='Animation_change' --  opcode_inj[vars.script_ref] stores vars
local inj_name='INJECT'..suffix
local pattern='^%s*mov.+%s*xmm%d+,%s*%[[^%]]+%]'
local aobs={'0F 28 44 24 20 41 0F 29 07 48 8B 4C 24 30',-10,16}
local lookahead_n=32

local inj_script=[[
define(${inj_name},${address_string})
    registersymbol(${inj_name})
    alloc(${newmem_name}, ${newmem_size}, ${inj_name})
	alloc(${varis_1_n}, $%d{varis_1_size}, ${inj_name})
    registersymbol(${varis_1_n})
	${varis_1_n}:
	${varis_1_d}

	label(code)
	label(return)

	${newmem_name}:
	code:
	    ${push_xmm}(9) //-10
		    movaps ${xmm~9},[${localAddress}+10]
	    ${push_xmm}(7)
${push_xmm}(6)
    push rcx
    push rbx
    push rax
	    ${push_xmm}(8)
    ${push_xmm}(4)
    ${push_xmm}(1)
    ${push_xmm}(2)
    ${push_xmm}(3)
    ${push_xmm}(5)
    ${push_xmm}(0)

${stack_push}(18)
    mov rax,[7FFE0014] //Windows internal clock
    mov rbx,rax
    shl rbx,6
    mov rcx,rax
    shl rcx,18
    imul rcx,rbx
    imul rcx,rax
    shr rcx,20 //ecx has the number

    cvtsi2ss ${xmm~7}, rcx
    cvtss2sd ${xmm~7}, ${xmm~7}

        mov [rsp],FFE00000
        mov [rsp+4],41EFFFFF //move max_float into stack
        divsd ${xmm~7}, [rsp] //div by max float (in double precision)


    cvtsd2ss ${xmm~7}, ${xmm~7} //random float in ${xmm~7}
	//pslldq ${x_reg},4
	movss ${x_reg}, ${xmm~7}

	cvtss2si ecx, ${xmm~7}  //b as int
    cvtsi2ss  ${xmm~8}, ecx // b
	//pslldq ${xmm~5},4
	movss ${xmm~5}, ${xmm~8}

    //ROUND 2

    mov rbx,[7FFE0014] //Windows internal clock
    mov rbx,rax
    shl rbx,6
    mov rcx,rax
    shl rcx,18
    imul rcx,rbx
    imul rcx,rax
    shr rcx,20 //ecx has the number

    cvtsi2ss ${xmm~7}, rcx
    cvtss2sd ${xmm~7}, ${xmm~7}

        mov [rsp],FFE00000
        mov [rsp+4],41EFFFFF //move max_float into stack
        divsd ${xmm~7}, [rsp] //div by max float (in double precision)


    cvtsd2ss ${xmm~7}, ${xmm~7} //random float in ${xmm~7}
	pslldq ${x_reg},4
	movss ${x_reg}, ${xmm~7}

	cvtss2si ecx, ${xmm~7}  //b as int
    cvtsi2ss  ${xmm~8}, ecx // b
	pslldq ${xmm~5},4
	movss ${xmm~5}, ${xmm~8}

	//ROUND 3

    mov rax,[7FFE0014] //Windows internal clock
    mov rbx,rax
    shl rbx,6
    mov rcx,rax
    shl rcx,18
    imul rcx,rbx
    imul rcx,rax
    shr rcx,20 //ecx has the number

    cvtsi2ss ${xmm~7}, rcx
    cvtss2sd ${xmm~7}, ${xmm~7}

        mov [rsp],FFE00000
        mov [rsp+4],41EFFFFF //move max_float into stack
        divsd ${xmm~7}, [rsp] //div by max float (in double precision)


    cvtsd2ss ${xmm~7}, ${xmm~7} //random float in ${xmm~7}
	pslldq ${x_reg},4
	movss ${x_reg}, ${xmm~7} // x_reg: (~,r,r,r)

    cvtss2si ecx, ${xmm~7}  //b as int
    cvtsi2ss  ${xmm~8}, ecx // b
	pslldq ${xmm~5},4
	movss ${xmm~5}, ${xmm~8} // x~5: (~,r,r,r)

	mov [rsp+8], C0000000 //-2
	mov [rsp+C], 3F800000 //1
	mov [rsp+10], 40000000 //2
	mov [rsp+14], 3F3504F3 //sqHalf

	movss ${xmm~1},  [rsp+14] //sqHalf
	shufps ${xmm~1},${xmm~1},0 // every element := [0]
	movss ${xmm~2}, [rsp+8] //-2
	shufps ${xmm~2},${xmm~2},0 // every element := [0]
	movss ${xmm~3}, [rsp+C] //1
	shufps ${xmm~3},${xmm~3},0 // every element := [0]
	movss ${xmm~4}, [rsp+10] //2
	shufps ${xmm~4},${xmm~4},0 // every element := [0]

	mulps ${xmm~4}, ${xmm~5} //x~4=b*2
	subps ${xmm~3}, ${xmm~4} // x~3=1-b*2
	mulps ${xmm~1}, ${xmm~3} // x~1 = ( sqHalf* (1-b*2) )
	mulps ${xmm~2}, ${xmm~5} //x~2 = -2*b
	mulps ${xmm~2}, ${x_reg} // x~2=(-2*b)*x
	addps ${xmm~2}, ${xmm~5}//x~2=(-2*b*x)+b
	addps ${xmm~2}, ${x_reg} // x~2=(-2*b*x)+b+x
	sqrtps ${xmm~2}, ${xmm~2} // // x~2=sqrt(-2*b*x+b+x)
	mulps  ${xmm~1},${xmm~2} // x~1 = ( sqHalf* (1-b*2) )*sqrt(-2*b*x+b+x)
	addps ${xmm~1}, ${xmm~5} //  x~1 = b+ ( sqHalf* (1-b*2) )*sqrt(-2*b*x+b+x) || FINAL!

	movss ${xmm~5}, [${varis_1_n}+4]
    movss ${xmm~4}, ${xmm~5} // (~,~,~,g)
	pslldq ${xmm~4},4 // (~,~,g,~)
	movss ${xmm~5}, [${varis_1_n}+C]
	movss ${xmm~4}, ${xmm~5} // (~,~,g,g)
	pslldq ${xmm~4},4 // (~,g,g,~)
    movss ${xmm~5}, [${varis_1_n}+14]
    movss ${xmm~4}, ${xmm~5} // (~,g,g,g)

	movss ${xmm~5}, [${varis_1_n}]
    movss ${xmm~3}, ${xmm~5} // (~,~,~,u)
	pslldq ${xmm~3},4 // (~,~,u,~)
	movss ${xmm~5}, [${varis_1_n}+8]
	movss ${xmm~3}, ${xmm~5} // (~,~,u,u)
	pslldq ${xmm~3},4 // (~,u,u,~)
    movss ${xmm~5}, [${varis_1_n}+10]
    movss ${xmm~3}, ${xmm~5} // (~,u,u,u)

	subps  ${xmm~3},  ${xmm~4}
    mulps  ${xmm~4},  ${xmm~1} //mul by adj_x
    addps  ${xmm~4},  ${xmm~4}
    addps  ${xmm~4},  ${xmm~3} //FINAL MULTS in x~4 !

	movdqu [rsp], ${xmm~4}
	mov [rsp+C], 3F800000 //1
	movups ${xmm~6}, [rsp] ////(1,mlt,mlt,mlt)

 ${stack_pop}(18)
    ${pop_xmm}(0)
    mulps ${xmm~9},${xmm~6}
    movups ${x_reg},${xmm~9}
    ${pop_xmm}(5)
    ${pop_xmm}(3)
    ${pop_xmm}(2)
    ${pop_xmm}(1)
    ${pop_xmm}(4)
    ${pop_xmm}(8)
    pop rax
    pop rbx
    pop rcx
      //${opcode}
      ${pop_xmm}(6)
	      ${pop_xmm}(7)
	      ${pop_xmm}(9)
      ${overwritten}
	  jmp return

	${inj_name}:
	  jmp ${newmem_name}
	  ${post_jmp}
	return:
]]

[ENABLE]
opcode_inj.inject(script_ref,inj_name,newmem_name,newmem_size,vars,inj_script,pattern,aobs,lookahead_n,parts,module_names)

[DISABLE]
opcode_inj.disable(script_ref)
opcode_inj[script_ref]=nil
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>1</ID>
              <Description>"Arms in/out average"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_1</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>6</ID>
              <Description>"Arms in/out range"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_1+4</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>32</ID>
              <Description>"Arm distance from body average"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_1+8</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>65</ID>
              <Description>"Arm distance from body range"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_1+C</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>64</ID>
              <Description>"Lean average"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_1+10</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>63</ID>
              <Description>"Lean range"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_1+14</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>7</ID>
          <Description>"Animation speed"</Description>
          <Options moHideChildren="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
local vars={}
--OPTIONAL (Add as named element of 'vars' table to use in '$%s{...}' notation)
local suffix='_5'
vars.varis_1_n='mult'..suffix

local m1=1 -- mean
local r1=0 -- range

vars.varis_1_d='dd (float)'..m1..'\ndd (float)'..r1
vars.varis_1_size=8   --(u +0, r +4, 0.5 +8, 1+C)

local parts={{'[^%]]+',1,'localAddress'},{'%d+',1,'xreg_n'},{'xmm%d+',1,'x_reg'},{'mov.+',1,'mov_op'}}
local module_names='PES2021.exe'
vars.post={}

vars.post[1]=function() --gives names "xmm~1" to "xmm~15" to all registers that are not 'x_reg'
 local xn=tonumber(vars.xreg_n)
 local c=1
 for i=0,15 do
  if xn~=i then
   vars['xmm~'..c]='xmm'..i
   c=c+1
  end
 end
 return vars --IMPORTANT!
end

-- token functions (below) run after ['post'] functions
vars['push_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s='sub rsp,10\nmovdqu [rsp], '
    if n=='0' then
		return s .. vars['x_reg']
	else
		return s .. vars['xmm~'..n]
	end
end

vars['pop_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s=',[rsp]\nadd rsp,10'
    if n=='0' then
		return 'movdqu '..vars['x_reg'] .. s
	else
		return 'movdqu '..vars['xmm~'..n] .. s
	end
end

vars['stack_push']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'sub rsp, ' .. n
end

vars['stack_pop']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'add rsp, ' .. n
end

--COMPULSORY
local newmem_name='newmem'..suffix
local newmem_size='$1000'
local script_ref='Animation_speed' --  opcode_inj[vars.script_ref] stores vars
local inj_name='INJECT'..suffix
local pattern='^%s*movss%s*%[[^%]]+%]%s*,%s*xmm%d+'
local aobs={'48 8B 40 10 F3 0F 11 48 44',0,16}
local lookahead_n=32

local inj_script=[[
  define(${inj_name},${address_string})
  registersymbol(${inj_name})
  alloc(${newmem_name}, ${newmem_size}, ${inj_name})

  alloc(${varis_1_n}, $%d{varis_1_size}, ${inj_name})
  registersymbol(${varis_1_n})
  ${varis_1_n}:
  ${varis_1_d}

  label(code)
  label(return)

  ${newmem_name}:
  code:
    push rcx
    push rbx
    push rax

    mov rax,[7FFE0014] //Windows internal clock
    mov rbx,rax
    shl rbx,6
    mov rcx,rax
    shl rcx,18
    imul rcx,rbx
    imul rcx,rax
    shr rcx,20 //ecx has the number
 ${push_xmm}(1)
    ${push_xmm}(2)
    ${push_xmm}(3)
    ${push_xmm}(4)
    ${push_xmm}(5)
    ${push_xmm}(0)

    cvtsi2ss ${x_reg}, rcx
    cvtss2sd ${x_reg}, ${x_reg}

    ${stack_push}(8)
        mov [rsp],FFE00000
        mov [rsp+4],41EFFFFF //move max_float into stack
        divsd ${x_reg}, [rsp] //div by max float (in double precision)
    ${stack_pop}(8)

    cvtsd2ss ${x_reg}, ${x_reg} //random float in ${x_reg}

    cvtss2si ecx, ${x_reg}  //b as int
    cvtsi2ss  ${xmm~5}, ecx // b

    ${stack_push}(10)
        mov [rsp], C0000000 //-2
        mov [rsp+4], 3F800000 //1
        mov [rsp+8], 40000000 //2
        mov [rsp+C], 3F3504F3 //sqHalf

        movss ${xmm~1},  [rsp+C] //sqHalf
        movss ${xmm~2}, [rsp] //-2
        movss ${xmm~3}, [rsp+4] //1
        movss ${xmm~4}, [rsp+8] //2

        mulss ${xmm~4}, ${xmm~5} //x~4=b*2
        subss ${xmm~3}, ${xmm~4} // x~3=1-b*2
        mulss ${xmm~1}, ${xmm~3} // x~1 = ( sqHalf* (1-b*2) )
        mulss ${xmm~2}, ${xmm~5} //x~2 = -2*b
        mulss ${xmm~2}, ${x_reg} // x~2=(-2*b)*x
        addss ${xmm~2}, ${xmm~5}//x~2=(-2*b*x)+b
        addss ${xmm~2}, ${x_reg} // x~2=(-2*b*x)+b+x
        sqrtss ${xmm~2}, ${xmm~2} // // x~2=sqrt(-2*b*x+b+x)
        mulss  ${xmm~1},${xmm~2} // x~1 = ( sqHalf* (1-b*2) )*sqrt(-2*b*x+b+x)
        addss ${xmm~1}, ${xmm~5} //  x~1 = b+ ( sqHalf* (1-b*2) )*sqrt(-2*b*x+b+x) || FINAL!
    ${stack_pop}(10)

    movss  ${xmm~4},  [${varis_1_n}+4]
    movss  ${xmm~3},  [${varis_1_n}] //u
    subss  ${xmm~3},  ${xmm~4}
    mulss  ${xmm~4},  ${xmm~1} //mul by adj_x
    addss  ${xmm~4},  ${xmm~4}
    addss  ${xmm~4},  ${xmm~3} //FINAL MULT in x~4 !

    ${pop_xmm}(0)
	mulss ${x_reg},${xmm~4}
    ${pop_xmm}(5)
    ${pop_xmm}(4)
    ${pop_xmm}(3)
    ${pop_xmm}(2)
    ${pop_xmm}(1)
    pop rax
    pop rbx
    pop rcx
    ${opcode}

    ${overwritten}
    jmp return

  ${inj_name}:
  jmp ${newmem_name}
  ${post_jmp}
  return:
]]

[ENABLE]
opcode_inj.inject(script_ref,inj_name,newmem_name,newmem_size,vars,inj_script,pattern,aobs,lookahead_n,parts,module_names)

[DISABLE]
opcode_inj.disable(script_ref)
opcode_inj[script_ref]=nil
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>31</ID>
              <Description>"Speed mean"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_5</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>61</ID>
              <Description>"Speed range"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_5+4</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>21</ID>
          <Description>"Pre-kick rush onto ball"</Description>
          <Options moHideChildren="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
local vars={}
--OPTIONAL (Add as named element of 'vars' table to use in '$%s{...}' notation)
local suffix='_2'
vars.varis_1_n='mult'..suffix

local rush=0.9964
vars.varis_1_d='dd (float)'..rush
vars.varis_1_size=4
local parts={{'[^%]]+',1,'localAddress'},{'%d+',1,'xreg_n'},{'xmm%d+',1,'x_reg'},{'mov.+',1,'mov_op'}}
local module_names='PES2021.exe'

--COMPULSORY
local newmem_name='newmem'..suffix
local newmem_size='$1000'
local script_ref='Pre_kick_rush' --  opcode_inj[vars.script_ref] stores vars
local inj_name='INJECT'..suffix
local pattern='^%s*movss%s*%[[^%]]+%]%s*,%s*xmm%d+'
local aobs={'F3 41 0F 11 5C 24 0C 48',-10,20}
local lookahead_n=32

local inj_script=[[
	define($%s{inj_name},$%s{address_string})
    registersymbol($%s{inj_name})
    alloc($%s{newmem_name}, $%s{newmem_size}, $%s{inj_name})
	alloc($%s{varis_1_n}, $%d{varis_1_size}, $%s{inj_name})
    registersymbol($%s{varis_1_n})
	$%s{varis_1_n}:
	$%s{varis_1_d}

	label(code)
	label(return)

	$%s{newmem_name}:
	code:
	  mulss $%s{x_reg},[$%s{varis_1_n}]
	  $%s{opcode}
      $%s{overwritten}
	  jmp return

	$%s{inj_name}:
	  jmp $%s{newmem_name}
	  $%s{post_jmp}
	return:
]]

[ENABLE]
opcode_inj.inject(script_ref,inj_name,newmem_name,newmem_size,vars,inj_script,pattern,aobs,lookahead_n,parts,module_names)

[DISABLE]
opcode_inj.disable(script_ref)
opcode_inj[script_ref]=nil
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>8</ID>
              <Description>"Acceleration"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_2</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>69</ID>
          <Description>"Broadcast focus"</Description>
          <Options moHideChildren="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
local vars={}
--OPTIONAL (Add as named element of 'vars' table to use in '$%s{...}' notation)
local suffix='_bcc'
vars.varis_1_n='mult'..suffix

local focus=0.025
vars.varis_1_d='dd (float)'..focus
vars.varis_1_size=4
local parts={{'[^%]]+',1,'localAddress'},{'%d+',1,'xreg_n'},{'xmm%d+',1,'x_reg'},{'mov.+',1,'mov_op'}}
local module_names='PES2021.exe'
vars.post={}

vars.post[1]=function() --gives names "xmm~1" to "xmm~15" to all registers that are not 'x_reg'
 local xn=tonumber(vars.xreg_n)
 local c=1
 for i=0,15 do
  if xn~=i then
   vars['xmm~'..c]='xmm'..i
   c=c+1
  end
 end
 return vars --IMPORTANT!
end

-- token functions (below) run after ['post'] functions
vars['push_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s='sub rsp,10\nmovdqu [rsp], '
    if n=='0' then
		return s .. vars['x_reg']
	else
		return s .. vars['xmm~'..n]
	end
end

vars['pop_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s=',[rsp]\nadd rsp,10'
    if n=='0' then
		return 'movdqu '..vars['x_reg'] .. s
	else
		return 'movdqu '..vars['xmm~'..n] .. s
	end
end

vars['stack_push']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'sub rsp, ' .. n
end

vars['stack_pop']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'add rsp, ' .. n
end


--COMPULSORY
local newmem_name='newmem'..suffix
local newmem_size='$1000'
local script_ref='Broadcast_focus' --  opcode_inj[vars.script_ref] stores vars
local inj_name='INJECT'..suffix
local pattern='^%s*mov.ps%s*xmm%d+%s*,%s*%[%s*%a+%d*%s*%+%s*%a+%d+%s*%]'
local aobs={'48 6B C8 58 8B 43 08 42 0F 10',6,8}
local lookahead_n=64

local inj_script=[[
	define($%s{inj_name},$%s{address_string})
    registersymbol($%s{inj_name})
    alloc($%s{newmem_name}, $%s{newmem_size}, $%s{inj_name})
	alloc($%s{varis_1_n}, $%d{varis_1_size}, $%s{inj_name})
    registersymbol($%s{varis_1_n})
	$%s{varis_1_n}:
	$%s{varis_1_d}

	label(code)
	label(return)

	$%s{newmem_name}:
	code:
    ${push_xmm}(1)
    ${stack_push}(20)
        mov [rsp], 3F800000 //1
        mov [rsp+4], 3F800000 //1
        mov [rsp+8], 3F800000 //1

        movss ${xmm~1}, [rbx+18] //ball pos (width)
        mulss ${xmm~1}, [${varis_1_n}]
        movss [rsp+C], ${xmm~1} //adj focus
        movups ${xmm~1}, [rsp]

	  ${opcode}
      mulps ${x_reg},${xmm~1}
      ${stack_pop}(20)
      ${pop_xmm}(1)
      ${overwritten}
	  jmp return


	$%s{inj_name}:
	  jmp $%s{newmem_name}
	  $%s{post_jmp}
	return:
]]

[ENABLE]
opcode_inj.inject(script_ref,inj_name,newmem_name,newmem_size,vars,inj_script,pattern,aobs,lookahead_n,parts,module_names)

[DISABLE]
opcode_inj.disable(script_ref)
opcode_inj[script_ref]=nil
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>70</ID>
              <Description>"Focus"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_bcc</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>74</ID>
          <Description>"Angle hijack (Stadium)"</Description>
          <Options moHideChildren="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
local vars={}
--OPTIONAL (Add as named element of 'vars' table to use in '$%s{...}' notation)
local suffix='_camAngle'
vars.varis_1_n='mult'..suffix

local angle=5
vars.varis_1_d='dd (float)'..angle
vars.varis_1_size=4
local parts={{'[^%]]+',1,'localAddress'},{'%d+',1,'xreg_n'},{'xmm%d+',1,'x_reg'},{'mov.+',1,'mov_op'}}
local module_names='PES2021.exe'
vars.post={}

vars.post[1]=function() --gives names "xmm~1" to "xmm~15" to all registers that are not 'x_reg'
 local xn=tonumber(vars.xreg_n)
 local c=1
 for i=0,15 do
  if xn~=i then
   vars['xmm~'..c]='xmm'..i
   c=c+1
  end
 end
 return vars --IMPORTANT!
end

-- token functions (below) run after ['post'] functions
vars['push_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s='sub rsp,10\nmovdqu [rsp], '
    if n=='0' then
		return s .. vars['x_reg']
	else
		return s .. vars['xmm~'..n]
	end
end

vars['pop_xmm']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
    local s=',[rsp]\nadd rsp,10'
    if n=='0' then
		return 'movdqu '..vars['x_reg'] .. s
	else
		return 'movdqu '..vars['xmm~'..n] .. s
	end
end

vars['stack_push']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'sub rsp, ' .. n
end

vars['stack_pop']=function(n) -- n, as all arguments used for token functions, is necessarily a string!
		return 'add rsp, ' .. n
end

--COMPULSORY
local newmem_name='newmem'..suffix
local newmem_size='$1000'
local script_ref='Hijack_angle' --  opcode_inj[vars.script_ref] stores vars
local inj_name='INJECT'..suffix
local pattern='^%s*movss%s*%[[^%]]+%]%s*,%s*xmm%d+'
local aobs={'40 10 F3 0F 11 48 14',0,4}
local lookahead_n=32

local inj_script=[[
	define($%s{inj_name},$%s{address_string})
    registersymbol($%s{inj_name})
    alloc($%s{newmem_name}, $%s{newmem_size}, $%s{inj_name})
	alloc($%s{varis_1_n}, $%d{varis_1_size}, $%s{inj_name})
    registersymbol($%s{varis_1_n})
	$%s{varis_1_n}:
	$%s{varis_1_d}

	label(code)
	label(return)

	$%s{newmem_name}:
	code:
	  mulss $%s{x_reg},[$%s{varis_1_n}]
	  $%s{opcode}
      $%s{overwritten}
	  jmp return

	$%s{inj_name}:
	  jmp $%s{newmem_name}
	  $%s{post_jmp}
	return:
]]

[ENABLE]
opcode_inj.inject(script_ref,inj_name,newmem_name,newmem_size,vars,inj_script,pattern,aobs,lookahead_n,parts,module_names)

{$asm}
aobscanmodule(INJECT_2,PES2021.exe,73 19 0F 2F CC 72) // should be unique
alloc(newmem_2,$1000,INJECT_2)

INJECT_2:
  db 90 90
registersymbol(INJECT_2)

aobscanmodule(INJECT_3,PES2021.exe,D6 01 76 45 F3 0F 10 05) // should be unique
alloc(newmem_3,$1000,INJECT_3)

INJECT_3:
  db D6 01 90 90
registersymbol(INJECT_3)


[DISABLE]
opcode_inj.disable(script_ref)
opcode_inj[script_ref]=nil

{$asm}
INJECT_2:
  db 73 19 0F 2F CC

unregistersymbol(INJECT_2)
dealloc(newmem_2)

INJECT_3:
  db D6 01 76 45

unregistersymbol(INJECT_3)
dealloc(newmem_3)

</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>72</ID>
              <Description>"Angle mult"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_camAngle</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>75</ID>
          <Description>"Cutscene heights fix"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
local vars={}
--OPTIONAL (Add as named element of 'vars' table to use in '$%s{...}' notation)
local suffix='_chg'
local parts={{'.+',1,'jb_address'}}
local module_names='PES2021.exe'

--COMPULSORY
local newmem_name='newmem'..suffix
local newmem_size='$1000'
local script_ref='Cutscenes_height' --  opcode_inj[vars.script_ref] stores vars
local inj_name='INJECT'..suffix
local pattern='^%s*jb%s+.+'
local aobs={'2F C5 72 05 0F 28 D1 EB 03',0,4}
local lookahead_n=32

local inj_script=[[
  define(${inj_name},${address_string})
  registersymbol(${inj_name})
  alloc(${newmem_name}, ${newmem_size}, ${inj_name})

  label(code)
  //label(return)

$%s{newmem_name}:
	code:
jmp ${jb_address}
      //$%s{overwritten}
	  //jmp return

 ${inj_name}:
	  jmp ${newmem_name}
  //${post_jmp}
  //return:
]]

[ENABLE]
opcode_inj.inject(script_ref,inj_name,newmem_name,newmem_size,vars,inj_script,pattern,aobs,lookahead_n,parts,module_names)

[DISABLE]
opcode_inj.disable(script_ref)
opcode_inj[script_ref]=nil
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>76</ID>
          <Description>"Smoother animation experiment"</Description>
          <Options moHideChildren="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
local vars={}
--OPTIONAL (Add as named element of 'vars' table to use in '$%s{...}' notation)
local suffix='_sma'
local parts={{'.+',1,'jne_address'}}
--COMPULSORY
local newmem_name='newmem'..suffix
local newmem_size='$1000'
local script_ref='Smooth_anim_exp' --  opcode_inj[vars.script_ref] stores vars
local inj_name='INJECT'..suffix
local pattern='^%s*jne%s+.+'
local aobs={'66 39 08 75 4A 41 81 BD 44 08 00 00 97 00 00 00',2,5}
local lookahead_n=32

local inj_script=[[

define(${inj_name},${address_string})
    registersymbol(${inj_name})
    alloc(${newmem_name}, ${newmem_size}, ${inj_name})

	label(code)
//label(return)

	$%s{newmem_name}:
	code:
    jmp ${jne_address}

	$%s{inj_name}:
	  jmp ${newmem_name}
	  ${post_jmp}
	//return:

]]

[ENABLE]
opcode_inj.inject(script_ref,inj_name,newmem_name,newmem_size,vars,inj_script,pattern,aobs,lookahead_n,parts,module_names)

[DISABLE]
opcode_inj.disable(script_ref)
opcode_inj[script_ref]=nil
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>79</ID>
          <Description>"Game speed (Lower is faster [1/x])"</Description>
          <Options moHideChildren="1"/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
local vars={}
--OPTIONAL (Add as named element of 'vars' table to use in '$%s{...}' notation)
local suffix='_speed'
vars.varis_1_n='mult'..suffix

local spd=1
vars.varis_1_d='dd (float)'..spd
vars.varis_1_size=4
local parts={{'xmm%d+',1,'x_reg'}}
local module_names='PES2021.exe'

--COMPULSORY
local newmem_name='newmem'..suffix
local newmem_size='$1000'
local script_ref='Game_speed' --  opcode_inj[vars.script_ref] stores vars
local inj_name='INJECT'..suffix
local pattern='^%s*movss%s+xmm%d+,%s*%[[^%]]+%]'
local aobs={'44 88 49 10 44 89 41 14 89 51 18',-127,-123}
local lookahead_n=32

local inj_script=[[
	define($%s{inj_name},$%s{address_string})
    registersymbol($%s{inj_name})
    alloc($%s{newmem_name}, $%s{newmem_size}, $%s{inj_name})
	alloc($%s{varis_1_n}, $%d{varis_1_size}, $%s{inj_name})
    registersymbol($%s{varis_1_n})
	$%s{varis_1_n}:
	$%s{varis_1_d}

	label(code)
	label(return)

	$%s{newmem_name}:
	code:
    ${opcode}
	  mulss ${x_reg},[${varis_1_n}]
      ${overwritten}
	  jmp return

	${inj_name}:
	  jmp ${newmem_name}
	  ${post_jmp}
	return:
]]

[ENABLE]
opcode_inj.inject(script_ref,inj_name,newmem_name,newmem_size,vars,inj_script,pattern,aobs,lookahead_n,parts,module_names)

[DISABLE]
opcode_inj.disable(script_ref)
opcode_inj[script_ref]=nil
</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>80</ID>
              <Description>"Speed"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Float</VariableType>
              <Address>mult_speed</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>
